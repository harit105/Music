# -*- coding: utf-8 -*-
"""Procedural audio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pQnWVJN5eYYchmspNhCjnrqeW6miqgfq
"""

pip install sounddevice numpy

import numpy as np
import matplotlib.pyplot as plt

# Audio parameters
sample_rate = 44100  # Hz
duration = 5  # seconds
t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False)
A = 0.5  # Amplitude
f = 440  # Frequency in Hz
T = 1 / f  # Period

# 1. Sine Wave
sine_wave = A * np.sin(2 * np.pi * f * t)

# 2. Sawtooth Wave
sawtooth_wave = 2 * A * ((t / T) - np.floor(0.5 + (t / T)))

# 3. Square Wave
square_wave = np.where(np.sin(2 * np.pi * f * t) >= 0, A, -A)

# 4. Amplitude-Modulated Wave (with 2 Hz LFO)
lfo = 0.5 * np.sin(2 * np.pi * 2 * t)
am_wave = (1 + lfo) * sine_wave

# 5. Unison Detuned Wave
detunes = [-2, 0, 2]
unison_wave = sum([
    (A / len(detunes)) * np.sin(2 * np.pi * (f + d) * t + np.random.uniform(0, 2*np.pi))
    for d in detunes
])

# üé® Visualization
waveforms = {
    "Sine Wave": sine_wave,
    "Sawtooth Wave": sawtooth_wave,
    "Square Wave": square_wave,
    "AM Modulated Wave": am_wave,
    "Unison Detuned Wave": unison_wave
}

# Plot first 1000 samples (~23 ms of audio)
sample_range = 1000
plt.figure(figsize=(16, 10))

for i, (label, wave) in enumerate(waveforms.items(), 1):
    plt.subplot(3, 2, i)
    plt.plot(t[:sample_range], wave[:sample_range], label=label)
    plt.title(label)
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.grid(True)

plt.tight_layout()
plt.suptitle("Generated Waveforms (First ~23 ms)", fontsize=16, y=1.02)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from IPython.display import Audio, display

# Audio parameters
sample_rate = 44100
segment_duration = 1.0  # seconds
A = 0.5
f_base = 220  # base frequency (A3)
t = np.linspace(0, segment_duration, int(sample_rate * segment_duration), endpoint=False)

# Waveform generator functions
def sine_wave(f): return A * np.sin(2 * np.pi * f * t)
def sawtooth_wave(f):
    T = 1 / f
    return 2 * A * ((t / T) - np.floor(0.5 + (t / T)))
def square_wave(f): return np.where(np.sin(2 * np.pi * f * t) >= 0, A, -A)
def am_wave(f, lfo_f=2):
    carrier = np.sin(2 * np.pi * f * t)
    lfo = 0.5 * np.sin(2 * np.pi * lfo_f * t)
    return A * (1 + lfo) * carrier
def unison_wave(f, detunes=[-2, 0, 2]):
    return sum([(A / len(detunes)) * np.sin(2 * np.pi * (f + d) * t + np.random.uniform(0, 2*np.pi)) for d in detunes])

# Waveform function dictionary
waveform_dict = {
    "sine": sine_wave,
    "saw": sawtooth_wave,
    "square": square_wave,
    "am": am_wave,
    "unison": unison_wave
}

# Composition: (waveform_type, frequency_multiplier)
composition = [
    ("sine", 1), ("saw", 1.25), ("square", 1.5),
    ("am", 2), ("unison", 2.5),
    ("sine", 1), ("unison", 2),
    ("square", 1.5), ("saw", 1.25)
]

# Generate combined audio signal
music = np.concatenate([
    waveform_dict[wave](f_base * mult)
    for wave, mult in composition
])

# Normalize audio for safe playback
music = music / np.max(np.abs(music))

# ‚ñ∂Ô∏è Play directly in memory (no file)
display(Audio(music, rate=sample_rate))

# üìà Plot waveform
plt.figure(figsize=(12, 4))
plt.plot(np.linspace(0, len(music) / sample_rate, len(music)), music, linewidth=0.5)
plt.title("Composed Music Waveform")
plt.xlabel("Time (seconds)")
plt.ylabel("Amplitude")
plt.grid(True)
plt.tight_layout()
plt.show()